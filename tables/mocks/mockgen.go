// Code generated by MockGen. DO NOT EDIT.
// Source: ../interface.go
//
// Generated by this command:
//
//	mockgen -source ../interface.go -destination ./mockgen.go -package mocks -exclude_interfaces ManagerOption
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gocqlx "github.com/scylladb/gocqlx/v3"
	qb "github.com/scylladb/gocqlx/v3/qb"
	metadata "github.com/zeroflucs-given/charybdis/metadata"
	tables "github.com/zeroflucs-given/charybdis/tables"
	gomock "go.uber.org/mock/gomock"
)

// MockTableManager is a mock of TableManager interface.
type MockTableManager[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockTableManagerMockRecorder[T]
	isgomock struct{}
}

// MockTableManagerMockRecorder is the mock recorder for MockTableManager.
type MockTableManagerMockRecorder[T any] struct {
	mock *MockTableManager[T]
}

// NewMockTableManager creates a new mock instance.
func NewMockTableManager[T any](ctrl *gomock.Controller) *MockTableManager[T] {
	mock := &MockTableManager[T]{ctrl: ctrl}
	mock.recorder = &MockTableManagerMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTableManager[T]) EXPECT() *MockTableManagerMockRecorder[T] {
	return m.recorder
}

// AddPostChangeHook mocks base method.
func (m *MockTableManager[T]) AddPostChangeHook(hook tables.ChangeHook[T]) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddPostChangeHook", hook)
}

// AddPostChangeHook indicates an expected call of AddPostChangeHook.
func (mr *MockTableManagerMockRecorder[T]) AddPostChangeHook(hook any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPostChangeHook", reflect.TypeOf((*MockTableManager[T])(nil).AddPostChangeHook), hook)
}

// AddPreChangeHook mocks base method.
func (m *MockTableManager[T]) AddPreChangeHook(hook tables.ChangeHook[T]) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddPreChangeHook", hook)
}

// AddPreChangeHook indicates an expected call of AddPreChangeHook.
func (mr *MockTableManagerMockRecorder[T]) AddPreChangeHook(hook any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPreChangeHook", reflect.TypeOf((*MockTableManager[T])(nil).AddPreChangeHook), hook)
}

// AddPreDeleteHook mocks base method.
func (m *MockTableManager[T]) AddPreDeleteHook(hook tables.ChangeHook[T]) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddPreDeleteHook", hook)
}

// AddPreDeleteHook indicates an expected call of AddPreDeleteHook.
func (mr *MockTableManagerMockRecorder[T]) AddPreDeleteHook(hook any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPreDeleteHook", reflect.TypeOf((*MockTableManager[T])(nil).AddPreDeleteHook), hook)
}

// Count mocks base method.
func (m *MockTableManager[T]) Count(ctx context.Context) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count", ctx)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockTableManagerMockRecorder[T]) Count(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockTableManager[T])(nil).Count), ctx)
}

// CountByCustomQuery mocks base method.
func (m *MockTableManager[T]) CountByCustomQuery(ctx context.Context, queryBuilder tables.QueryBuilderFn) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountByCustomQuery", ctx, queryBuilder)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountByCustomQuery indicates an expected call of CountByCustomQuery.
func (mr *MockTableManagerMockRecorder[T]) CountByCustomQuery(ctx, queryBuilder any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountByCustomQuery", reflect.TypeOf((*MockTableManager[T])(nil).CountByCustomQuery), ctx, queryBuilder)
}

// CountByPartitionKey mocks base method.
func (m *MockTableManager[T]) CountByPartitionKey(ctx context.Context, partitionKeys ...any) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range partitionKeys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CountByPartitionKey", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountByPartitionKey indicates an expected call of CountByPartitionKey.
func (mr *MockTableManagerMockRecorder[T]) CountByPartitionKey(ctx any, partitionKeys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, partitionKeys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountByPartitionKey", reflect.TypeOf((*MockTableManager[T])(nil).CountByPartitionKey), varargs...)
}

// Delete mocks base method.
func (m *MockTableManager[T]) Delete(ctx context.Context, instance *T) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, instance)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockTableManagerMockRecorder[T]) Delete(ctx, instance any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockTableManager[T])(nil).Delete), ctx, instance)
}

// DeleteByPrimaryKey mocks base method.
func (m *MockTableManager[T]) DeleteByPrimaryKey(ctx context.Context, keys ...any) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteByPrimaryKey", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteByPrimaryKey indicates an expected call of DeleteByPrimaryKey.
func (mr *MockTableManagerMockRecorder[T]) DeleteByPrimaryKey(ctx any, keys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteByPrimaryKey", reflect.TypeOf((*MockTableManager[T])(nil).DeleteByPrimaryKey), varargs...)
}

// DeleteUsingOptions mocks base method.
func (m *MockTableManager[T]) DeleteUsingOptions(ctx context.Context, opts ...tables.DeleteOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteUsingOptions", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteUsingOptions indicates an expected call of DeleteUsingOptions.
func (mr *MockTableManagerMockRecorder[T]) DeleteUsingOptions(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUsingOptions", reflect.TypeOf((*MockTableManager[T])(nil).DeleteUsingOptions), varargs...)
}

// GetByIndexedColumn mocks base method.
func (m *MockTableManager[T]) GetByIndexedColumn(ctx context.Context, columnName string, value any, opts ...tables.QueryOption) (*T, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, columnName, value}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetByIndexedColumn", varargs...)
	ret0, _ := ret[0].(*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByIndexedColumn indicates an expected call of GetByIndexedColumn.
func (mr *MockTableManagerMockRecorder[T]) GetByIndexedColumn(ctx, columnName, value any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, columnName, value}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByIndexedColumn", reflect.TypeOf((*MockTableManager[T])(nil).GetByIndexedColumn), varargs...)
}

// GetByPartitionKey mocks base method.
func (m *MockTableManager[T]) GetByPartitionKey(ctx context.Context, keys ...any) (*T, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetByPartitionKey", varargs...)
	ret0, _ := ret[0].(*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByPartitionKey indicates an expected call of GetByPartitionKey.
func (mr *MockTableManagerMockRecorder[T]) GetByPartitionKey(ctx any, keys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByPartitionKey", reflect.TypeOf((*MockTableManager[T])(nil).GetByPartitionKey), varargs...)
}

// GetByPrimaryKey mocks base method.
func (m *MockTableManager[T]) GetByPrimaryKey(ctx context.Context, primaryKeys ...any) (*T, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range primaryKeys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetByPrimaryKey", varargs...)
	ret0, _ := ret[0].(*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByPrimaryKey indicates an expected call of GetByPrimaryKey.
func (mr *MockTableManagerMockRecorder[T]) GetByPrimaryKey(ctx any, primaryKeys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, primaryKeys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByPrimaryKey", reflect.TypeOf((*MockTableManager[T])(nil).GetByPrimaryKey), varargs...)
}

// GetSession mocks base method.
func (m *MockTableManager[T]) GetSession() any {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSession")
	ret0, _ := ret[0].(any)
	return ret0
}

// GetSession indicates an expected call of GetSession.
func (mr *MockTableManagerMockRecorder[T]) GetSession() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSession", reflect.TypeOf((*MockTableManager[T])(nil).GetSession))
}

// GetTableSpec mocks base method.
func (m *MockTableManager[T]) GetTableSpec() *metadata.TableSpecification {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTableSpec")
	ret0, _ := ret[0].(*metadata.TableSpecification)
	return ret0
}

// GetTableSpec indicates an expected call of GetTableSpec.
func (mr *MockTableManagerMockRecorder[T]) GetTableSpec() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTableSpec", reflect.TypeOf((*MockTableManager[T])(nil).GetTableSpec))
}

// GetUsingOptions mocks base method.
func (m *MockTableManager[T]) GetUsingOptions(ctx context.Context, opts ...tables.QueryOption) (*T, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUsingOptions", varargs...)
	ret0, _ := ret[0].(*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUsingOptions indicates an expected call of GetUsingOptions.
func (mr *MockTableManagerMockRecorder[T]) GetUsingOptions(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUsingOptions", reflect.TypeOf((*MockTableManager[T])(nil).GetUsingOptions), varargs...)
}

// Insert mocks base method.
func (m *MockTableManager[T]) Insert(ctx context.Context, instance *T, options ...tables.InsertOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, instance}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Insert", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Insert indicates an expected call of Insert.
func (mr *MockTableManagerMockRecorder[T]) Insert(ctx, instance any, options ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, instance}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockTableManager[T])(nil).Insert), varargs...)
}

// InsertBulk mocks base method.
func (m *MockTableManager[T]) InsertBulk(ctx context.Context, instances []*T, concurrency int, opts ...tables.InsertOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, instances, concurrency}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertBulk", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertBulk indicates an expected call of InsertBulk.
func (mr *MockTableManagerMockRecorder[T]) InsertBulk(ctx, instances, concurrency any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, instances, concurrency}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertBulk", reflect.TypeOf((*MockTableManager[T])(nil).InsertBulk), varargs...)
}

// InsertOrReplace mocks base method.
func (m *MockTableManager[T]) InsertOrReplace(ctx context.Context, instance *T, options ...tables.InsertOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, instance}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOrReplace", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertOrReplace indicates an expected call of InsertOrReplace.
func (mr *MockTableManagerMockRecorder[T]) InsertOrReplace(ctx, instance any, options ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, instance}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrReplace", reflect.TypeOf((*MockTableManager[T])(nil).InsertOrReplace), varargs...)
}

// Scan mocks base method.
func (m *MockTableManager[T]) Scan(ctx context.Context, fn tables.PageHandlerFn[T], opts ...tables.QueryOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, fn}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockTableManagerMockRecorder[T]) Scan(ctx, fn any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, fn}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockTableManager[T])(nil).Scan), varargs...)
}

// SelectByCustomQuery mocks base method.
func (m *MockTableManager[T]) SelectByCustomQuery(ctx context.Context, queryBuilder tables.QueryBuilderFn, pagingFn tables.PageHandlerFn[T], opts ...tables.QueryOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, queryBuilder, pagingFn}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SelectByCustomQuery", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SelectByCustomQuery indicates an expected call of SelectByCustomQuery.
func (mr *MockTableManagerMockRecorder[T]) SelectByCustomQuery(ctx, queryBuilder, pagingFn any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, queryBuilder, pagingFn}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectByCustomQuery", reflect.TypeOf((*MockTableManager[T])(nil).SelectByCustomQuery), varargs...)
}

// SelectByIndexedColumn mocks base method.
func (m *MockTableManager[T]) SelectByIndexedColumn(ctx context.Context, fn tables.PageHandlerFn[T], columnName string, columnValue any, opts ...tables.QueryOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, fn, columnName, columnValue}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SelectByIndexedColumn", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SelectByIndexedColumn indicates an expected call of SelectByIndexedColumn.
func (mr *MockTableManagerMockRecorder[T]) SelectByIndexedColumn(ctx, fn, columnName, columnValue any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, fn, columnName, columnValue}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectByIndexedColumn", reflect.TypeOf((*MockTableManager[T])(nil).SelectByIndexedColumn), varargs...)
}

// SelectByPartitionKey mocks base method.
func (m *MockTableManager[T]) SelectByPartitionKey(ctx context.Context, fn tables.PageHandlerFn[T], opts []tables.QueryOption, partitionKeys ...any) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, fn, opts}
	for _, a := range partitionKeys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SelectByPartitionKey", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SelectByPartitionKey indicates an expected call of SelectByPartitionKey.
func (mr *MockTableManagerMockRecorder[T]) SelectByPartitionKey(ctx, fn, opts any, partitionKeys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, fn, opts}, partitionKeys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectByPartitionKey", reflect.TypeOf((*MockTableManager[T])(nil).SelectByPartitionKey), varargs...)
}

// SelectByPrimaryKey mocks base method.
func (m *MockTableManager[T]) SelectByPrimaryKey(ctx context.Context, fn tables.PageHandlerFn[T], opts []tables.QueryOption, primaryKeys ...any) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, fn, opts}
	for _, a := range primaryKeys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SelectByPrimaryKey", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SelectByPrimaryKey indicates an expected call of SelectByPrimaryKey.
func (mr *MockTableManagerMockRecorder[T]) SelectByPrimaryKey(ctx, fn, opts any, primaryKeys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, fn, opts}, primaryKeys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectByPrimaryKey", reflect.TypeOf((*MockTableManager[T])(nil).SelectByPrimaryKey), varargs...)
}

// Update mocks base method.
func (m *MockTableManager[T]) Update(ctx context.Context, instance *T, opts ...tables.UpdateOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, instance}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Update", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockTableManagerMockRecorder[T]) Update(ctx, instance any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, instance}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockTableManager[T])(nil).Update), varargs...)
}

// Upsert mocks base method.
func (m *MockTableManager[T]) Upsert(ctx context.Context, instance *T, opts ...tables.UpsertOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, instance}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Upsert", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Upsert indicates an expected call of Upsert.
func (mr *MockTableManagerMockRecorder[T]) Upsert(ctx, instance any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, instance}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockTableManager[T])(nil).Upsert), varargs...)
}

// UpsertBulk mocks base method.
func (m *MockTableManager[T]) UpsertBulk(ctx context.Context, instances []*T, concurrency int, opts ...tables.UpsertOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, instances, concurrency}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpsertBulk", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertBulk indicates an expected call of UpsertBulk.
func (mr *MockTableManagerMockRecorder[T]) UpsertBulk(ctx, instances, concurrency any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, instances, concurrency}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertBulk", reflect.TypeOf((*MockTableManager[T])(nil).UpsertBulk), varargs...)
}

// MockViewManager is a mock of ViewManager interface.
type MockViewManager[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockViewManagerMockRecorder[T]
	isgomock struct{}
}

// MockViewManagerMockRecorder is the mock recorder for MockViewManager.
type MockViewManagerMockRecorder[T any] struct {
	mock *MockViewManager[T]
}

// NewMockViewManager creates a new mock instance.
func NewMockViewManager[T any](ctrl *gomock.Controller) *MockViewManager[T] {
	mock := &MockViewManager[T]{ctrl: ctrl}
	mock.recorder = &MockViewManagerMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockViewManager[T]) EXPECT() *MockViewManagerMockRecorder[T] {
	return m.recorder
}

// CountByCustomQuery mocks base method.
func (m *MockViewManager[T]) CountByCustomQuery(ctx context.Context, queryBuilder tables.QueryBuilderFn) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountByCustomQuery", ctx, queryBuilder)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountByCustomQuery indicates an expected call of CountByCustomQuery.
func (mr *MockViewManagerMockRecorder[T]) CountByCustomQuery(ctx, queryBuilder any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountByCustomQuery", reflect.TypeOf((*MockViewManager[T])(nil).CountByCustomQuery), ctx, queryBuilder)
}

// CountByPartitionKey mocks base method.
func (m *MockViewManager[T]) CountByPartitionKey(ctx context.Context, partitionKeys ...any) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range partitionKeys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CountByPartitionKey", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountByPartitionKey indicates an expected call of CountByPartitionKey.
func (mr *MockViewManagerMockRecorder[T]) CountByPartitionKey(ctx any, partitionKeys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, partitionKeys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountByPartitionKey", reflect.TypeOf((*MockViewManager[T])(nil).CountByPartitionKey), varargs...)
}

// GetByIndexedColumn mocks base method.
func (m *MockViewManager[T]) GetByIndexedColumn(ctx context.Context, columnName string, value any, opts ...tables.QueryOption) (*T, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, columnName, value}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetByIndexedColumn", varargs...)
	ret0, _ := ret[0].(*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByIndexedColumn indicates an expected call of GetByIndexedColumn.
func (mr *MockViewManagerMockRecorder[T]) GetByIndexedColumn(ctx, columnName, value any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, columnName, value}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByIndexedColumn", reflect.TypeOf((*MockViewManager[T])(nil).GetByIndexedColumn), varargs...)
}

// GetByPartitionKey mocks base method.
func (m *MockViewManager[T]) GetByPartitionKey(ctx context.Context, keys ...any) (*T, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetByPartitionKey", varargs...)
	ret0, _ := ret[0].(*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByPartitionKey indicates an expected call of GetByPartitionKey.
func (mr *MockViewManagerMockRecorder[T]) GetByPartitionKey(ctx any, keys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByPartitionKey", reflect.TypeOf((*MockViewManager[T])(nil).GetByPartitionKey), varargs...)
}

// GetByPrimaryKey mocks base method.
func (m *MockViewManager[T]) GetByPrimaryKey(ctx context.Context, primaryKeys ...any) (*T, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range primaryKeys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetByPrimaryKey", varargs...)
	ret0, _ := ret[0].(*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByPrimaryKey indicates an expected call of GetByPrimaryKey.
func (mr *MockViewManagerMockRecorder[T]) GetByPrimaryKey(ctx any, primaryKeys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, primaryKeys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByPrimaryKey", reflect.TypeOf((*MockViewManager[T])(nil).GetByPrimaryKey), varargs...)
}

// GetUsingOptions mocks base method.
func (m *MockViewManager[T]) GetUsingOptions(ctx context.Context, opts ...tables.QueryOption) (*T, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUsingOptions", varargs...)
	ret0, _ := ret[0].(*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUsingOptions indicates an expected call of GetUsingOptions.
func (mr *MockViewManagerMockRecorder[T]) GetUsingOptions(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUsingOptions", reflect.TypeOf((*MockViewManager[T])(nil).GetUsingOptions), varargs...)
}

// Scan mocks base method.
func (m *MockViewManager[T]) Scan(ctx context.Context, fn tables.PageHandlerFn[T], opts ...tables.QueryOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, fn}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockViewManagerMockRecorder[T]) Scan(ctx, fn any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, fn}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockViewManager[T])(nil).Scan), varargs...)
}

// SelectByCustomQuery mocks base method.
func (m *MockViewManager[T]) SelectByCustomQuery(ctx context.Context, queryBuilder tables.QueryBuilderFn, pagingFn tables.PageHandlerFn[T], opts ...tables.QueryOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, queryBuilder, pagingFn}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SelectByCustomQuery", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SelectByCustomQuery indicates an expected call of SelectByCustomQuery.
func (mr *MockViewManagerMockRecorder[T]) SelectByCustomQuery(ctx, queryBuilder, pagingFn any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, queryBuilder, pagingFn}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectByCustomQuery", reflect.TypeOf((*MockViewManager[T])(nil).SelectByCustomQuery), varargs...)
}

// SelectByIndexedColumn mocks base method.
func (m *MockViewManager[T]) SelectByIndexedColumn(ctx context.Context, fn tables.PageHandlerFn[T], columnName string, columnValue any, opts ...tables.QueryOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, fn, columnName, columnValue}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SelectByIndexedColumn", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SelectByIndexedColumn indicates an expected call of SelectByIndexedColumn.
func (mr *MockViewManagerMockRecorder[T]) SelectByIndexedColumn(ctx, fn, columnName, columnValue any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, fn, columnName, columnValue}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectByIndexedColumn", reflect.TypeOf((*MockViewManager[T])(nil).SelectByIndexedColumn), varargs...)
}

// SelectByPartitionKey mocks base method.
func (m *MockViewManager[T]) SelectByPartitionKey(ctx context.Context, fn tables.PageHandlerFn[T], opts []tables.QueryOption, partitionKeys ...any) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, fn, opts}
	for _, a := range partitionKeys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SelectByPartitionKey", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SelectByPartitionKey indicates an expected call of SelectByPartitionKey.
func (mr *MockViewManagerMockRecorder[T]) SelectByPartitionKey(ctx, fn, opts any, partitionKeys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, fn, opts}, partitionKeys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectByPartitionKey", reflect.TypeOf((*MockViewManager[T])(nil).SelectByPartitionKey), varargs...)
}

// SelectByPrimaryKey mocks base method.
func (m *MockViewManager[T]) SelectByPrimaryKey(ctx context.Context, fn tables.PageHandlerFn[T], opts []tables.QueryOption, primaryKeys ...any) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, fn, opts}
	for _, a := range primaryKeys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SelectByPrimaryKey", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SelectByPrimaryKey indicates an expected call of SelectByPrimaryKey.
func (mr *MockViewManagerMockRecorder[T]) SelectByPrimaryKey(ctx, fn, opts any, primaryKeys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, fn, opts}, primaryKeys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectByPrimaryKey", reflect.TypeOf((*MockViewManager[T])(nil).SelectByPrimaryKey), varargs...)
}

// MockInsertOption is a mock of InsertOption interface.
type MockInsertOption struct {
	ctrl     *gomock.Controller
	recorder *MockInsertOptionMockRecorder
	isgomock struct{}
}

// MockInsertOptionMockRecorder is the mock recorder for MockInsertOption.
type MockInsertOptionMockRecorder struct {
	mock *MockInsertOption
}

// NewMockInsertOption creates a new mock instance.
func NewMockInsertOption(ctrl *gomock.Controller) *MockInsertOption {
	mock := &MockInsertOption{ctrl: ctrl}
	mock.recorder = &MockInsertOptionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInsertOption) EXPECT() *MockInsertOptionMockRecorder {
	return m.recorder
}

// applyToInsertBuilder mocks base method.
func (m *MockInsertOption) applyToInsertBuilder(builder *qb.InsertBuilder) *qb.InsertBuilder {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "applyToInsertBuilder", builder)
	ret0, _ := ret[0].(*qb.InsertBuilder)
	return ret0
}

// applyToInsertBuilder indicates an expected call of applyToInsertBuilder.
func (mr *MockInsertOptionMockRecorder) applyToInsertBuilder(builder any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "applyToInsertBuilder", reflect.TypeOf((*MockInsertOption)(nil).applyToInsertBuilder), builder)
}

// isPrecondition mocks base method.
func (m *MockInsertOption) isPrecondition() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "isPrecondition")
	ret0, _ := ret[0].(bool)
	return ret0
}

// isPrecondition indicates an expected call of isPrecondition.
func (mr *MockInsertOptionMockRecorder) isPrecondition() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "isPrecondition", reflect.TypeOf((*MockInsertOption)(nil).isPrecondition))
}

// MockDeleteOption is a mock of DeleteOption interface.
type MockDeleteOption struct {
	ctrl     *gomock.Controller
	recorder *MockDeleteOptionMockRecorder
	isgomock struct{}
}

// MockDeleteOptionMockRecorder is the mock recorder for MockDeleteOption.
type MockDeleteOptionMockRecorder struct {
	mock *MockDeleteOption
}

// NewMockDeleteOption creates a new mock instance.
func NewMockDeleteOption(ctrl *gomock.Controller) *MockDeleteOption {
	mock := &MockDeleteOption{ctrl: ctrl}
	mock.recorder = &MockDeleteOptionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeleteOption) EXPECT() *MockDeleteOptionMockRecorder {
	return m.recorder
}

// applyToQuery mocks base method.
func (m *MockDeleteOption) applyToQuery(query *gocqlx.Queryx) *gocqlx.Queryx {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "applyToQuery", query)
	ret0, _ := ret[0].(*gocqlx.Queryx)
	return ret0
}

// applyToQuery indicates an expected call of applyToQuery.
func (mr *MockDeleteOptionMockRecorder) applyToQuery(query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "applyToQuery", reflect.TypeOf((*MockDeleteOption)(nil).applyToQuery), query)
}

// bindings mocks base method.
func (m *MockDeleteOption) bindings() []any {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "bindings")
	ret0, _ := ret[0].([]any)
	return ret0
}

// bindings indicates an expected call of bindings.
func (mr *MockDeleteOptionMockRecorder) bindings() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "bindings", reflect.TypeOf((*MockDeleteOption)(nil).bindings))
}

// columns mocks base method.
func (m *MockDeleteOption) columns() []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "columns")
	ret0, _ := ret[0].([]string)
	return ret0
}

// columns indicates an expected call of columns.
func (mr *MockDeleteOptionMockRecorder) columns() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "columns", reflect.TypeOf((*MockDeleteOption)(nil).columns))
}

// predicates mocks base method.
func (m *MockDeleteOption) predicates() []qb.Cmp {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "predicates")
	ret0, _ := ret[0].([]qb.Cmp)
	return ret0
}

// predicates indicates an expected call of predicates.
func (mr *MockDeleteOptionMockRecorder) predicates() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "predicates", reflect.TypeOf((*MockDeleteOption)(nil).predicates))
}

// MockQueryOption is a mock of QueryOption interface.
type MockQueryOption struct {
	ctrl     *gomock.Controller
	recorder *MockQueryOptionMockRecorder
	isgomock struct{}
}

// MockQueryOptionMockRecorder is the mock recorder for MockQueryOption.
type MockQueryOptionMockRecorder struct {
	mock *MockQueryOption
}

// NewMockQueryOption creates a new mock instance.
func NewMockQueryOption(ctrl *gomock.Controller) *MockQueryOption {
	mock := &MockQueryOption{ctrl: ctrl}
	mock.recorder = &MockQueryOptionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQueryOption) EXPECT() *MockQueryOptionMockRecorder {
	return m.recorder
}

// applyToBuilder mocks base method.
func (m *MockQueryOption) applyToBuilder(builder *qb.SelectBuilder) *qb.SelectBuilder {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "applyToBuilder", builder)
	ret0, _ := ret[0].(*qb.SelectBuilder)
	return ret0
}

// applyToBuilder indicates an expected call of applyToBuilder.
func (mr *MockQueryOptionMockRecorder) applyToBuilder(builder any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "applyToBuilder", reflect.TypeOf((*MockQueryOption)(nil).applyToBuilder), builder)
}

// applyToQuery mocks base method.
func (m *MockQueryOption) applyToQuery(query *gocqlx.Queryx) *gocqlx.Queryx {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "applyToQuery", query)
	ret0, _ := ret[0].(*gocqlx.Queryx)
	return ret0
}

// applyToQuery indicates an expected call of applyToQuery.
func (mr *MockQueryOptionMockRecorder) applyToQuery(query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "applyToQuery", reflect.TypeOf((*MockQueryOption)(nil).applyToQuery), query)
}

// bindings mocks base method.
func (m *MockQueryOption) bindings() []any {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "bindings")
	ret0, _ := ret[0].([]any)
	return ret0
}

// bindings indicates an expected call of bindings.
func (mr *MockQueryOptionMockRecorder) bindings() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "bindings", reflect.TypeOf((*MockQueryOption)(nil).bindings))
}

// columns mocks base method.
func (m *MockQueryOption) columns() []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "columns")
	ret0, _ := ret[0].([]string)
	return ret0
}

// columns indicates an expected call of columns.
func (mr *MockQueryOptionMockRecorder) columns() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "columns", reflect.TypeOf((*MockQueryOption)(nil).columns))
}

// MockUpdateOption is a mock of UpdateOption interface.
type MockUpdateOption struct {
	ctrl     *gomock.Controller
	recorder *MockUpdateOptionMockRecorder
	isgomock struct{}
}

// MockUpdateOptionMockRecorder is the mock recorder for MockUpdateOption.
type MockUpdateOptionMockRecorder struct {
	mock *MockUpdateOption
}

// NewMockUpdateOption creates a new mock instance.
func NewMockUpdateOption(ctrl *gomock.Controller) *MockUpdateOption {
	mock := &MockUpdateOption{ctrl: ctrl}
	mock.recorder = &MockUpdateOptionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpdateOption) EXPECT() *MockUpdateOptionMockRecorder {
	return m.recorder
}

// applyToUpdateBuilder mocks base method.
func (m *MockUpdateOption) applyToUpdateBuilder(builder *qb.UpdateBuilder) *qb.UpdateBuilder {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "applyToUpdateBuilder", builder)
	ret0, _ := ret[0].(*qb.UpdateBuilder)
	return ret0
}

// applyToUpdateBuilder indicates an expected call of applyToUpdateBuilder.
func (mr *MockUpdateOptionMockRecorder) applyToUpdateBuilder(builder any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "applyToUpdateBuilder", reflect.TypeOf((*MockUpdateOption)(nil).applyToUpdateBuilder), builder)
}

// getMapData mocks base method.
func (m *MockUpdateOption) getMapData() map[string]any {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "getMapData")
	ret0, _ := ret[0].(map[string]any)
	return ret0
}

// getMapData indicates an expected call of getMapData.
func (mr *MockUpdateOptionMockRecorder) getMapData() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getMapData", reflect.TypeOf((*MockUpdateOption)(nil).getMapData))
}

// isPrecondition mocks base method.
func (m *MockUpdateOption) isPrecondition() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "isPrecondition")
	ret0, _ := ret[0].(bool)
	return ret0
}

// isPrecondition indicates an expected call of isPrecondition.
func (mr *MockUpdateOptionMockRecorder) isPrecondition() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "isPrecondition", reflect.TypeOf((*MockUpdateOption)(nil).isPrecondition))
}

// MockUpsertOption is a mock of UpsertOption interface.
type MockUpsertOption struct {
	ctrl     *gomock.Controller
	recorder *MockUpsertOptionMockRecorder
	isgomock struct{}
}

// MockUpsertOptionMockRecorder is the mock recorder for MockUpsertOption.
type MockUpsertOptionMockRecorder struct {
	mock *MockUpsertOption
}

// NewMockUpsertOption creates a new mock instance.
func NewMockUpsertOption(ctrl *gomock.Controller) *MockUpsertOption {
	mock := &MockUpsertOption{ctrl: ctrl}
	mock.recorder = &MockUpsertOptionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpsertOption) EXPECT() *MockUpsertOptionMockRecorder {
	return m.recorder
}

// applyToInsertBuilder mocks base method.
func (m *MockUpsertOption) applyToInsertBuilder(builder *qb.InsertBuilder) *qb.InsertBuilder {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "applyToInsertBuilder", builder)
	ret0, _ := ret[0].(*qb.InsertBuilder)
	return ret0
}

// applyToInsertBuilder indicates an expected call of applyToInsertBuilder.
func (mr *MockUpsertOptionMockRecorder) applyToInsertBuilder(builder any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "applyToInsertBuilder", reflect.TypeOf((*MockUpsertOption)(nil).applyToInsertBuilder), builder)
}

// applyToUpdateBuilder mocks base method.
func (m *MockUpsertOption) applyToUpdateBuilder(builder *qb.UpdateBuilder) *qb.UpdateBuilder {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "applyToUpdateBuilder", builder)
	ret0, _ := ret[0].(*qb.UpdateBuilder)
	return ret0
}

// applyToUpdateBuilder indicates an expected call of applyToUpdateBuilder.
func (mr *MockUpsertOptionMockRecorder) applyToUpdateBuilder(builder any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "applyToUpdateBuilder", reflect.TypeOf((*MockUpsertOption)(nil).applyToUpdateBuilder), builder)
}

// getMapData mocks base method.
func (m *MockUpsertOption) getMapData() map[string]any {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "getMapData")
	ret0, _ := ret[0].(map[string]any)
	return ret0
}

// getMapData indicates an expected call of getMapData.
func (mr *MockUpsertOptionMockRecorder) getMapData() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getMapData", reflect.TypeOf((*MockUpsertOption)(nil).getMapData))
}

// isPrecondition mocks base method.
func (m *MockUpsertOption) isPrecondition() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "isPrecondition")
	ret0, _ := ret[0].(bool)
	return ret0
}

// isPrecondition indicates an expected call of isPrecondition.
func (mr *MockUpsertOptionMockRecorder) isPrecondition() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "isPrecondition", reflect.TypeOf((*MockUpsertOption)(nil).isPrecondition))
}
